import ManageNode,Linking,GuiArray,Algorithms
import  math,numpy

import pickle
from tkinter import *
# import Tkinter
import tkinter.filedialog
from tkinter.simpledialog import askstring
from tkinter import messagebox

root = Tk()
topFrame = Frame(root)
topFrame.pack(fill=X)
topFrame2 = Frame(root)
topFrame2.pack(fill=X)
bottomFrame = Frame(root)
bottomFrame.pack(side=BOTTOM)

# canvas
canvas = Canvas(root, width=1000,height=600,bg="light gray")
canvas.pack(expand=1,fill=BOTH)

#creating objects - link to the classes in the folder
GA=GuiArray.guiArray(canvas)
MN=ManageNode.manageNode()
LK=Linking.Graph()
AL=Algorithms.algorithms(LK.vert_dict)

global coordinates
coordinates=[]

#drop down list

# create buttons
button1 = Button(topFrame,text="Create Node")
button2 = Button(topFrame,text="Create Link")
button3 = Button(topFrame,text="Create Probability Tables")
# button4 = Button(topFrame,text="Choose Probability Label")
button4 = Button(topFrame,text="Set Probability")
button6 = Button(topFrame,text="Set Observation")
button7 = Button(bottomFrame,text="Run")

button1.pack(side=LEFT)
button2.pack(side=LEFT)
button3.pack(side=LEFT)
button4.pack(side=LEFT)
# button5.pack(side=LEFT)
button6.pack(side=LEFT)
button7.pack(side=LEFT)

# methods called by buttons
node_id_Dic={}
prob_table_id={}
# draw on the canvas
def drawNode(e):
    #if not means if it's empty then do operation

    #canvas enclosed creates a space around where you click and checks no other objects are in that area
    #if objects are present it wont create a node there

    #if is empty then creates the oval

    if not canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105):
        oval=canvas.create_oval(e.x-50,e.y-50,e.x+50,e.y+40)

        value = askstring('value', 'Please enter a title')

      #MN.inc means increase that method by 1 as new node was created

        nodeID=MN.inc()

        nodeName=value

        #nickname given to each node
        nickname=canvas.create_text(e.x,e.y,text=str(value))

    coordinateSet=[nodeName,[e.x,e.y]]

    GUIset = [nodeName, nodeID, {}]  # number object / oval object / dictionary for linking

    node_id_Dic[oval] = nodeID
    LK.add_vertex(nodeID)
    GA.addNode(GUIset,nodeID)
    GA.addCoords(coordinateSet,nodeID)

# listen to mouse action
def CreateNode(event):
    root.config(cursor="")
    canvas.bind("<Button-1>",drawNode)

# need to change these values so it includes table try a smaller size
#try another method so it connects to the edge of the oval
#alt try it adds a weight but just doesnt show it
def ArcPoint2(e):
    if len(canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105))==2:
        toNode=node_id_Dic[canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105)[0]]#the node is created before num so it is at [0]
        if (fromNode is not toNode)and(LK.check_edge_existed(fromNode,toNode)==False):
            root.config(cursor="")
            arrow = canvas.create_line(x,y,e.x,e.y,arrow="last")#fill="turquoise" can change color

            GA.addBeliefArrow(fromNode, toNode, arrow)

            # #this method produces the connection

            LK.add_edge(fromNode,toNode)

            canvas.bind("<Button-1>",ArcPoint1)

# listen to the first click for the line
def ArcPoint1(e):
    #==2 need to change this to == length of string input +1
    if len(canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105))==2:
    #global equivalent of instance variable
    #used this so its able to be used by different methods
    #x,y =location and fromNode = the id of the node you pick up - the one you draw FROM
        global x,y,fromNode
        x,y=e.x,e.y
        fromNode=node_id_Dic[canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105)[0]]
        root.config(cursor="cross")
        canvas.bind("<Button-1>",ArcPoint2)
# listen to the mouse action
def CreateArc(event):
    root.config(cursor="")
    canvas.bind("<Button-1>",ArcPoint1)

def CreateTable(parent,coordinate):

    #need to handle error that doesnt keep drawing mutiple rows each time you refresh it

    #need to change from p to the set part that does parent no.s
    for p in range(2**len(parent)):
        coordinate[1] = coordinate[1] + 30
        #print box 1&2 again but lower than previous row and do for the same amount of times as p

        box1 = canvas.create_rectangle(coordinate[0] - 140, coordinate[1], coordinate[0] - 100, coordinate[1]-30)
        box2 = canvas.create_rectangle(coordinate[0] - 60, coordinate[1], coordinate[0] - 100, coordinate[1]-30)

    # rows = 2**len(parent)
    #
    # v=  bin(rows)[2:].zfill(len(parent))
    # print(v)

#use a for loop to make the rows for each box as in the box is the for loop

def probTable(event):

#need to store a DICTIONARY not list
#has nodeID and their links
#then proceed to make the tables 8

    parentNodes={}
    for k in GA.nodeList:
        parentNodes[k]=set()

    if LK.num_vertices>0:

        for j in GA.nodeList:
            #go through nodes and check if they have parents
            #then use child id as a key and value as a list and append parent into the list

            for i in GA.nodeList[j][2]:
                if GA.nodeList[j][2]:
                    parentNodes[i].add(j)

                    print(parentNodes)


    for x in parentNodes:

        point=GA.coordList[x][1]

        CreateTable(parentNodes[x],point)

def setProblabel(e):

    global valueLab


    valueLabel = askstring('value', 'Please enter either T or F')

    valueL = canvas.create_text(e.x, e.y, text=str(valueLabel))

    valueLab=valueLabel

    labCoord=[valueLabel,[e.x,e.y]]
    print(labCoord)

    valueP = askstring('value', 'Please enter a probability value')

    valueprob = getdouble(valueP)

    # if false box is clicked enter value
    if not canvas.find_enclosed(e.x - 20, e.y, e.x + 20, e.y + 30):
        canvas.create_text(e.x+35, e.y, text=valueprob)

    pc = [valueprob, [e.x+35, e.y]]
    print(pc)

    #make a getter

  #store this label with the nodeID
    #then late use this to store in a set


def ParentProb(event):
    root.config(cursor="cross")
    canvas.bind("<Button-1>", setProblabel)

#
# def setProb(e):
#
#     x = e.x
#     y = e.y
#
#     valueP = askstring('value', 'Please enter a probability value')
#
#     valueprob = getdouble(valueP)
#
#     # if false box is clicked enter value
#     if not canvas.find_enclosed(e.x - 20, e.y, e.x + 20, e.y + 30):
#         canvas.create_text(e.x, e.y, text=valueprob)
#
#     pc = [valueprob,[e.x,e.y]]
#     print(pc)

        #now use these coordinates to match the range of the nodeid its next to
        #store this with the nodeID and label from above

        #atm probset is overwriting unless do each button alternatively
    # probset = [valueLab, valueprob]
    # probset = {}
    #
    # checkCoords={}
    #
    # for q in GA.coordList:
    #     checkCoords[q] = set()
    #
    #     if x >0:
    #         for w in GA.coordList:
    #             for t in GA.coordList[w][1]:
    #                 if GA.coordList[w][1]:
    #                     print("skssksksk")
    #                     if x in range(t):
    #                         print(w)
    #                         probset=[w,valueLab,valueprob]
    #                         print(probset)
    #
    #                         #need to not overwrite probset


# parentNodes = {}
        # for k in GA.nodeList:
        #     parentNodes[k] = set()
        #
        # if LK.num_vertices > 0:
        #     print("bbbb")
        #     for j in GA.nodeList:
        #         # go through nodes and check if they have parents
        #         # then use child id as a key and value as a list and append parent into the list
        #
        #         for i in GA.nodeList[j][2]:
        #             if GA.nodeList[j][2]:
        #                 parentNodes[i].add(j)
        #
        #                 print(parentNodes)

        # for x in parentNodes:
        #     print('yyy')
        #     point = GA.coordList[x][1]
        #     print("oooo")
        #     CreateTable(parentNodes[x], point)

#
# def ParentProb(event):
#     root.config(cursor="cross")
#     canvas.bind("<Button-1>", setProb)



def setTF(e): #change this to run the algorithm too

    #alternatively do a drop down list of all the nodes from the dictionary
    #instead of an entry box - true false cancel and whichever is selected rpogerss from there
    x = e.x

    # checkCoords={}
    #
    # for q in GA.coordList:
    #     checkCoords[q] = set()
    #
    #     if x >0:
    #         for w in GA.coordList:
    #             for t in GA.coordList[w][1]:
    #                 if GA.coordList[w][1]:
    #                     print("skssksksk")
    #                     if x in range(0,t):
    #                         print(w)
    #                         probset=[w,valueLab,valueprob]
    #                         print(probset)

    obsLabel = askstring('value', 'Please enter either T or F')

    # obsCoord = {}
    # obs = {}
    # for h in GA.coordList:
    #     obsCoord[h] = set()
    #
    #     if x>0:
    #         for f in GA.coordList:
    #             for d in GA.coordList[f][1]:
    #                 if GA.coordList[f][1]:
    #                     print("werterwt")
    #                     if x ==d:
    #                         print(f)


    #need it to not overwrite one another
    if obsLabel == 'T':
        obs = [obsLabel]
        print(obs)
    elif obsLabel == 'F':
        obs = [obsLabel]
        print(obs)
    elif obsLabel is None:
        print("asassa")
    else:
        #dont print the label
        obsError = tkinter.messagebox.showinfo('error','Please only enter either T or F')

    return obs
    print(obs)

        # trueVar=IntVar()
    # valueObs = tkinter.
    # obsTrue = Checkbutton(canvas,text="True",variable=trueVar)


    # #want a dictionary store nodeID and T/F
    #
    # Label(root, text="Select Node:").pack(side=LEFT)
    #
    # e1 = Entry(root)
    #
    # e1.pack(side=LEFT)
    #
    # chosenNode = e1.get()
    #
    # #check after input then print
    # #alt create a button that confirms the input then prints
    # #store in a list - as order is necessary must be t/f then value
    #
    # print("aaaaaa")
    # print(chosenNode) #not printing????
    # print("bbbb")
    #
    #
    # global truevar
    #
    # truevar = IntVar()
    #
    # true = Checkbutton(root, text="True", variable=truevar)
    # true.pack(side=LEFT)
    #
    # falsevar=IntVar()
    # false = Checkbutton(root, text="False", variable=falsevar)
    # false.pack(side=LEFT)
    # falsevar.get()
    # # print(falsevar.get())
    #
    #
    # print("eeeee")
    # truevar.get()
    #
    # print(truevar.get())
    #
    #
    #
    # print("ccccc")

def SetObs(event):
    root.config(cursor="cross")
    canvas.bind("<Button-1>", setTF)

def run(event):
    print("asdawdwa")


button1.bind("<Button-1>",CreateNode)
button2.bind("<Button-1>",CreateArc)
button3.bind("<Button-1>",probTable)
button4.bind("<Button-1>",ParentProb)
# button5.bind("<Button-1>",ParentProb)
button6.bind("<Button-1>", SetObs)
button7.bind("<Button-1>",run)


root.mainloop()

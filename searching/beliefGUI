import ManageNode,Linking,GuiArray,Algorithms
import  math,numpy

import pickle
from tkinter import *
# import Tkinter
import tkinter.filedialog
from tkinter.simpledialog import askstring
from tkinter import messagebox

root = Tk()
topFrame = Frame(root)
topFrame.pack(fill=X)
topFrame2 = Frame(root)
topFrame2.pack(fill=X)
bottomFrame = Frame(root)
bottomFrame.pack(side=BOTTOM)

# canvas
canvas = Canvas(root, width=1000,height=600,bg="light gray")
canvas.pack(expand=1,fill=BOTH)

#creating objects - link to the classes in the folder
GA=GuiArray.guiArray(canvas)
MN=ManageNode.manageNode()
LK=Linking.Graph()
AL=Algorithms.algorithms(LK.vert_dict)

global coordinates
coordinates=[]

global horizdiff

global vertdiff


#drop down list

# create buttons
button1 = Button(topFrame,text="Create Node")
button2 = Button(topFrame,text="Create Link")
button3 = Button(topFrame,text="Create Probability Tables")
button4 = Button(topFrame,text="Set Probability Label and Value")
button6 = Button(topFrame,text="Set Observation")
button7 = Button(bottomFrame,text="Run")

button1.pack(side=LEFT)
button2.pack(side=LEFT)
button3.pack(side=LEFT)
button4.pack(side=LEFT)
# button5.pack(side=LEFT)
button6.pack(side=LEFT)
button7.pack(side=LEFT)

# methods called by buttons
node_id_Dic={}
prob_table_id={}
# draw on the canvas
def drawNode(e):
    #if not means if it's empty then do operation

    #canvas enclosed creates a space around where you click and checks no other objects are in that area
    #if objects are present it wont create a node there

    #if is empty then creates the oval

    if not canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105):
        oval=canvas.create_oval(e.x-50,e.y-50,e.x+50,e.y+40)

        value = askstring('value', 'Please enter a title')

      #MN.inc means increase that method by 1 as new node was created

        nodeID=MN.inc()

        nodeName=value

        #nickname given to each node
        nickname=canvas.create_text(e.x,e.y,text=str(value))

        coordinateSet=[nodeName,e.x,e.y]

        # xcoordSet = [nodeName,e.x]

        GUIset = [nodeName, nodeID, {},oval]  # number object / oval object / dictionary for linking

        node_id_Dic[oval] = nodeID
        LK.add_vertex(nodeID)
        GA.addNode(GUIset,nodeID)
        GA.addCoords(coordinateSet,nodeID)
        # GA.addXcoords(xcoordSet,nodeID)

# listen to mouse action
def CreateNode(event):
    root.config(cursor="")
    canvas.bind("<Button-1>",drawNode)

# need to change these values so it includes table try a smaller size
#try another method so it connects to the edge of the oval
#alt try it adds a weight but just doesnt show it
def ArcPoint2(e):
    if len(canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105))==2:
        toNode=node_id_Dic[canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105)[0]]#the node is created before num so it is at [0]
        if (fromNode is not toNode)and(LK.check_edge_existed(fromNode,toNode)==False):
            root.config(cursor="")
            arrow = canvas.create_line(x,y,e.x,e.y,arrow="last")#fill="turquoise" can change color

            GA.addBeliefArrow(fromNode, toNode, arrow)

            # #this method produces the connection

            LK.add_edge(fromNode,toNode)

            canvas.bind("<Button-1>",ArcPoint1)

# listen to the first click for the line
def ArcPoint1(e):
    #==2 need to change this to == length of string input +1
    if len(canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105))==2:
    #global equivalent of instance variable
    #used this so its able to be used by different methods
    #x,y =location and fromNode = the id of the node you pick up - the one you draw FROM
        global x,y,fromNode
        x,y=e.x,e.y
        fromNode=node_id_Dic[canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105)[0]]
        root.config(cursor="cross")
        canvas.bind("<Button-1>",ArcPoint2)
# listen to the mouse action
def CreateArc(event):
    root.config(cursor="")
    canvas.bind("<Button-1>",ArcPoint1)

def CreateTable(parent,coordinateX,coordinateY):

 #need to handle error that doesnt keep drawing mutiple rows each time you refresh it
    #if not enclosed in this space - distance from nodeid then draw the below

    #need to change from p to the set part that does parent no.s
    for p in range(2**len(parent)):
        coordinateY = coordinateY + 30
        #print box 1&2 again but lower than previous row and do for the same amount of times as p

        box1 = canvas.create_rectangle(coordinateX - 140, coordinateY, coordinateX - 100, coordinateY-30)
        box2 = canvas.create_rectangle(coordinateX - 60, coordinateY, coordinateX - 100, coordinateY-30)

    AL.generateProbabilityTable()

    # rows = 2**len(parent)
    #
    # v=  bin(rows)[2:].zfill(len(parent))
    # print(v)

#use a for loop to make the rows for each box as in the box is the for loop

def probTable(event):

#need to store a DICTIONARY not list
#has nodeID and their links
#then proceed to make the tables 8
    global parentNodes
    parentNodes={}
    for k in GA.nodeList:
        parentNodes[k]=set()

    if LK.num_vertices>0:

        for j in GA.nodeList:
            #go through nodes and check if they have parents
            #then use child id as a key and value as a list and append parent into the list

            for i in GA.nodeList[j][2]:
                if GA.nodeList[j][2]:
                    parentNodes[i].add(j)

                    print(parentNodes)

    for x in parentNodes:

        pointX=GA.coordList[x][1]
        pointY=GA.coordList[x][2]

        CreateTable(parentNodes[x],pointX,pointY)


def setProblabel(e):

    global valueLab


    valueLabel = askstring('value', 'Please enter either T or F')

    valueL = canvas.create_text(e.x, e.y, text=str(valueLabel))

    valueLab=valueLabel

    labCoord=[valueLabel,e.x,e.y]
    print(labCoord)

    valueP = askstring('value', 'Please enter a probability value')

    valueprob = getdouble(valueP)

    # if false box is clicked enter value
    if not canvas.find_enclosed(e.x - 20, e.y, e.x + 20, e.y + 30):
        canvas.create_text(e.x+35, e.y, text=valueprob)

    pc = [valueprob,e.x+35, e.y]
    print(pc)


    for i in GA.coordList:

        if GA.coordList[i]:


            print('node x ' + str(GA.coordList[i][1]))
            print('point x ' + str(pc[1]))

            horizdiff=(GA.coordList[i][1]-pc[1])

            print("point horiz " + str(horizdiff))


            vertdiff=abs((GA.coordList[i][2]-pc[2]))


            print('node y ' + str(GA.coordList[i][2]))
            print('point y ' + str(pc[2]))
            print("vert diff: " + str(vertdiff))


            if horizdiff <100 and horizdiff >60:

                #for each row check y
                #when this becomes true then assign the value to that row

                print("row test")

                for n in range((2**(len(parentNodes[i])))):

                    stringNode = str(i)
                    stringRow = str(n+1)

                    stringID = str(stringNode+'.'+stringRow)

                    print("test id" +stringID)
                    # print(n)
                    # print("nr")

                    if vertdiff > (n*30) and vertdiff < ((n+1)*30):
                        row = n+1
                        print('row: ' + str(row))


                        global probset #also want row on the end
                        probset=[i,(2**(len(parentNodes[i]))),valueLabel,valueprob,row]
                        print(probset)
                        GA.addProbs(probset, stringID)
                        if probset[2]=='F':
                            AL.setKnownPT(i, 'T', 1-probset[3])
                        else:
                            AL.setKnownPT(i,probset[2],probset[3])
                            print(probset[2])
                            print(probset[3])




def ParentProb(event):
    root.config(cursor="cross")
    canvas.bind("<Button-1>", setProblabel)


def setTF(e): #change this to run the algorithm too

    global obset
    obset = []


    #alternatively do a drop down list of all the nodes from the dictionary
    #instead of an entry box - true false cancel and whichever is selected rpogerss from there
    x = e.x
    y = e.y

    # checkCoords={}
    #
    # for q in GA.coordList:
    #     checkCoords[q] = set()
    #
    #     if x >0:
    #         for w in GA.coordList:
    #             for t in GA.coordList[w][1]:
    #                 if GA.coordList[w][1]:
    #                     print("skssksksk")
    #                     if x in range(0,t):
    #                         print(w)
    #                         probset=[w,valueLab,valueprob]
    #                         print(probset)

    obsLabel = askstring('value', 'Please enter either T or F')


    if obsLabel == 'T':
        # obs = [obsLabel]
        # print(obs)
        for i in GA.coordList:
            if GA.coordList[i]:
                if x > GA.coordList[i][1] - 50 and x < GA.coordList[i][1] + 50:
                    print("x test")

                    if y < GA.coordList[i][2] + 40 and y > GA.coordList[i][2] - 50:
                        print("colour test" + str(i))
                        canvas.itemconfig(GA.nodeList[i][3], fill="green")
                        print("y test")

                        for j in GA.probDict:
                            # print(j)
                            print(i)
                            if GA.probDict[j][0]==i:
                                # for l in GA.probDict[j][2]:
                                    if obsLabel == GA.probDict[j][2]:
                                        obset = obsLabel
                                        print(obset)
                                        GA.addObs(obset, i)

                                    else:

                                        obset = 'T'
                                        print(obset)
                                        GA.addObs(obset, i)



    elif obsLabel == 'F':
        # obs = [obsLabel]
        # print(obs)
        for i in GA.coordList:
            if GA.coordList[i]:
                if x > GA.coordList[i][1] - 50 and x < GA.coordList[i][1] + 50:
                    print("x test")

                    if y < GA.coordList[i][2] + 40 and y > GA.coordList[i][2] - 50:
                        print("colour test" + str(i))
                        canvas.itemconfig(GA.nodeList[i][3], fill="red")
                        print("y test")

                        for j in GA.probDict:
                            # print(j)
                            print(i)
                            if GA.probDict[j][0] == i:
                                # for l in GA.probDict[j][2]:
                                if obsLabel == GA.probDict[j][2]:
                                    obset = obsLabel
                                    print(obset)
                                    GA.addObs(obset, i)
                                else:

                                    obset = 'F'
                                    print(obset)

                                    GA.addObs(obset,i)

    elif obsLabel is None:
        print("ACTION CANCELLED")
    else:
        #dont print the label
        obsError = tkinter.messagebox.showinfo('error','Please only enter either T or F')

def SetObs(event):
    root.config(cursor="cross")
    canvas.bind("<Button-1>", setTF)

def run(event):   #############call display method in here - see mainframe
    print("asdawdwa")
    AL.generatePriorProbability()

    for z in LK.vert_dict:
        print("PROB VALUE" + str(z) + str(LK.vert_dict[z].probability))

    AL.refreshP(GA.obsList)
    print("AL test: " + str(AL.refreshP(GA.obsList)))

    resultsDisplay()
    root.update()



def resultsDisplay():
    resultcanvas = Frame(root)
    resultcanvas.pack(side=BOTTOM)


########DISPLAY RESULTS - literally just call the above print statement
#and split the results into each node ie relevant labels

#use the below so this makes the result canvas accorsding and change to relevant results
    finalPathLabel = Label(resultcanvas, bg="red", text="Final path: ")
    finalPathLabel.grid(column=0, row=0, sticky=W)
    # final path for the bfs
    finalPathValue = Label(resultcanvas, text=str(1))
    finalPathValue.grid(column=1, row=0, sticky=W)










button1.bind("<Button-1>",CreateNode)
button2.bind("<Button-1>",CreateArc)
button3.bind("<Button-1>",probTable)
button4.bind("<Button-1>",ParentProb)
button6.bind("<Button-1>", SetObs)
button7.bind("<Button-1>",run)


root.mainloop()

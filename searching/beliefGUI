import ManageNode,Linking,GuiArray,Algorithms
import  math,numpy

import pickle
from tkinter import *
# import Tkinter
import tkinter.filedialog
from tkinter.simpledialog import askstring
from tkinter import messagebox

root = Tk()
topFrame = Frame(root)
topFrame.pack(fill=X)
topFrame2 = Frame(root)
topFrame2.pack(fill=X)
bottomFrame = Frame(root)
bottomFrame.pack(side=BOTTOM)

# canvas
canvas = Canvas(root, width=1000,height=600,bg="light gray")
canvas.pack(expand=1,fill=BOTH)

#creating objects - link to the classes in the folder
GA=GuiArray.guiArray(canvas)
MN=ManageNode.manageNode()
LK=Linking.Graph()
AL=Algorithms.algorithms(LK.vert_dict)

global coordinates
coordinates=[]

global horizLimit
horizLimit=(140*140)

global vertLimit

global distsquared

global dist


#drop down list

# create buttons
button1 = Button(topFrame,text="Create Node")
button2 = Button(topFrame,text="Create Link")
button3 = Button(topFrame,text="Create Probability Tables")
button4 = Button(topFrame,text="Set Probability Label and Value")
button6 = Button(topFrame,text="Set Observation")
button7 = Button(bottomFrame,text="Run")

button1.pack(side=LEFT)
button2.pack(side=LEFT)
button3.pack(side=LEFT)
button4.pack(side=LEFT)
# button5.pack(side=LEFT)
button6.pack(side=LEFT)
button7.pack(side=LEFT)

# methods called by buttons
node_id_Dic={}
prob_table_id={}
# draw on the canvas
def drawNode(e):
    #if not means if it's empty then do operation

    #canvas enclosed creates a space around where you click and checks no other objects are in that area
    #if objects are present it wont create a node there

    #if is empty then creates the oval

    if not canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105):
        oval=canvas.create_oval(e.x-50,e.y-50,e.x+50,e.y+40)

        value = askstring('value', 'Please enter a title')

      #MN.inc means increase that method by 1 as new node was created

        nodeID=MN.inc()

        nodeName=value

        #nickname given to each node
        nickname=canvas.create_text(e.x,e.y,text=str(value))

    coordinateSet=[nodeName,e.x,e.y]

    # xcoordSet = [nodeName,e.x]

    GUIset = [nodeName, nodeID, {}]  # number object / oval object / dictionary for linking

    node_id_Dic[oval] = nodeID
    LK.add_vertex(nodeID)
    GA.addNode(GUIset,nodeID)
    GA.addCoords(coordinateSet,nodeID)
    # GA.addXcoords(xcoordSet,nodeID)

# listen to mouse action
def CreateNode(event):
    root.config(cursor="")
    canvas.bind("<Button-1>",drawNode)

# need to change these values so it includes table try a smaller size
#try another method so it connects to the edge of the oval
#alt try it adds a weight but just doesnt show it
def ArcPoint2(e):
    if len(canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105))==2:
        toNode=node_id_Dic[canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105)[0]]#the node is created before num so it is at [0]
        if (fromNode is not toNode)and(LK.check_edge_existed(fromNode,toNode)==False):
            root.config(cursor="")
            arrow = canvas.create_line(x,y,e.x,e.y,arrow="last")#fill="turquoise" can change color

            GA.addBeliefArrow(fromNode, toNode, arrow)

            # #this method produces the connection

            LK.add_edge(fromNode,toNode)

            canvas.bind("<Button-1>",ArcPoint1)

# listen to the first click for the line
def ArcPoint1(e):
    #==2 need to change this to == length of string input +1
    if len(canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105))==2:
    #global equivalent of instance variable
    #used this so its able to be used by different methods
    #x,y =location and fromNode = the id of the node you pick up - the one you draw FROM
        global x,y,fromNode
        x,y=e.x,e.y
        fromNode=node_id_Dic[canvas.find_enclosed(e.x-105,e.y-105,e.x+105,e.y+105)[0]]
        root.config(cursor="cross")
        canvas.bind("<Button-1>",ArcPoint2)
# listen to the mouse action
def CreateArc(event):
    root.config(cursor="")
    canvas.bind("<Button-1>",ArcPoint1)

def CreateTable(parent,coordinateX,coordinateY):

 #need to handle error that doesnt keep drawing mutiple rows each time you refresh it
    #if not enclosed in this space - distance from nodeid then draw the below

    #need to change from p to the set part that does parent no.s
    for p in range(2**len(parent)):
        coordinateY = coordinateY + 30
        #print box 1&2 again but lower than previous row and do for the same amount of times as p

        box1 = canvas.create_rectangle(coordinateX - 140, coordinateY, coordinateX - 100, coordinateY-30)
        box2 = canvas.create_rectangle(coordinateX - 60, coordinateY, coordinateX - 100, coordinateY-30)

    # rows = 2**len(parent)
    #
    # v=  bin(rows)[2:].zfill(len(parent))
    # print(v)

#use a for loop to make the rows for each box as in the box is the for loop

def probTable(event):

#need to store a DICTIONARY not list
#has nodeID and their links
#then proceed to make the tables 8

    parentNodes={}
    for k in GA.nodeList:
        parentNodes[k]=set()

    if LK.num_vertices>0:

        for j in GA.nodeList:
            #go through nodes and check if they have parents
            #then use child id as a key and value as a list and append parent into the list

            for i in GA.nodeList[j][2]:
                if GA.nodeList[j][2]:
                    parentNodes[i].add(j)

                    print(parentNodes)



    for x in parentNodes:

        pointX=GA.coordList[x][1]
        pointY=GA.coordList[x][2]

        CreateTable(parentNodes[x],pointX,pointY)

    #need to store these in a dict with nodeID and value
        vertLimit = (2 ** len(parentNodes[x]) * 30)

        print("vert limit" +str(vertLimit))

        vertLimitsquared = vertLimit ** 2

        print("vert limited sq" + str(vertLimitsquared))

        distsquared = horizLimit + (vertLimit ** 2)

        dist = distsquared ** 0.5

        print("dist" + str(dist))


        distSet=[x,dist]

        print("distset "+ str(distSet))

        GA.addDists(distSet,x)



def setProblabel(e):

    global valueLab


    valueLabel = askstring('value', 'Please enter either T or F')

    valueL = canvas.create_text(e.x, e.y, text=str(valueLabel))

    valueLab=valueLabel

    labCoord=[valueLabel,e.x,e.y]
    print(labCoord)

    valueP = askstring('value', 'Please enter a probability value')

    valueprob = getdouble(valueP)

    # if false box is clicked enter value
    if not canvas.find_enclosed(e.x - 20, e.y, e.x + 20, e.y + 30):
        canvas.create_text(e.x+35, e.y, text=valueprob)

    pc = [valueprob,e.x+35, e.y]
    print(pc)



    # FOR EVERY PROB VALUE DO THE DISTANCE LIKE METHOD ABOVE

    # vertLimit = (2 ** len(parentNodes[x]) * 30)
    #
    # print(vertLimit)
    #
    # vertLimitsquared = vertLimit ** 2
    #
    # print(vertLimitsquared)
    #
    # distsquared = horizLimit + (vertLimit ** 2)
    #
    # dist = distsquared ** 0.5
    #
    # print(dist)
    #
    # distSet = [x, dist]
    #
    # print(distSet)
    #
    # GA.addDists(distSet, x)

    for i in GA.coordList:

        if GA.coordList[i]:

            print("coordlist X " + str(GA.coordList[i][1]))

            print("point x " + str(pc[1]))

            pointHoriz=((GA.coordList[i][1]-pc[1])**2)

            print("point horiz " + str(pointHoriz))


            print( "coord list Y " + str(GA.coordList[i][2]))

            print("point y " + str(pc[2]))

            pointVert=((GA.coordList[i][2]-pc[2])**2)

            print("point vert "+str(pointVert))

            pointDistSQ = pointHoriz+pointVert

            print("point dist sq "+str(pointDistSQ))

            pointDist=pointDistSQ**0.5

            print("point dist " + str(pointDist))

            for j in GA.distDict:
                print("test")
                if GA.distDict[j]:
                    print("DIstdict[i][1]" + str(GA.distDict[j][1]))

                    if pointDist < GA.distDict[j][1]:

                        #reverse it through to find the coordX no. then find node id attached
                        print("nodeID")
                        print(i)
                        global probset
                        probset = [i,valueLabel, valueprob]
                        print(probset)

                #go through dist dictionary and get id
                # print(GA.addDists[i])


def ParentProb(event):
    root.config(cursor="cross")
    canvas.bind("<Button-1>", setProblabel)

#
# def setProb(e):
#
#     x = e.x
#     y = e.y
#
#     valueP = askstring('value', 'Please enter a probability value')
#
#     valueprob = getdouble(valueP)
#
#     # if false box is clicked enter value
#     if not canvas.find_enclosed(e.x - 20, e.y, e.x + 20, e.y + 30):
#         canvas.create_text(e.x, e.y, text=valueprob)
#
#     pc = [valueprob,[e.x,e.y]]
#     print(pc)

        #now use these coordinates to match the range of the nodeid its next to
        #store this with the nodeID and label from above

        #atm probset is overwriting unless do each button alternatively
    # probset = [valueLab, valueprob]
    # probset = {}
    #
    # checkCoords={}
    #
    # for q in GA.coordList:
    #     checkCoords[q] = set()
    #
    #     if x >0:
    #         for w in GA.coordList:
    #             for t in GA.coordList[w][1]:
    #                 if GA.coordList[w][1]:
    #                     print("skssksksk")
    #                     if x in range(t):
    #                         print(w)
    #                         probset=[w,valueLab,valueprob]
    #                         print(probset)
    #
    #                         #need to not overwrite probset


# parentNodes = {}
        # for k in GA.nodeList:
        #     parentNodes[k] = set()
        #
        # if LK.num_vertices > 0:
        #     print("bbbb")
        #     for j in GA.nodeList:
        #         # go through nodes and check if they have parents
        #         # then use child id as a key and value as a list and append parent into the list
        #
        #         for i in GA.nodeList[j][2]:
        #             if GA.nodeList[j][2]:
        #                 parentNodes[i].add(j)
        #
        #                 print(parentNodes)

        # for x in parentNodes:
        #     print('yyy')
        #     point = GA.coordList[x][1]
        #     print("oooo")
        #     CreateTable(parentNodes[x], point)

#
# def ParentProb(event):
#     root.config(cursor="cross")
#     canvas.bind("<Button-1>", setProb)



def setTF(e): #change this to run the algorithm too

    #alternatively do a drop down list of all the nodes from the dictionary
    #instead of an entry box - true false cancel and whichever is selected rpogerss from there
    x = e.x

    # checkCoords={}
    #
    # for q in GA.coordList:
    #     checkCoords[q] = set()
    #
    #     if x >0:
    #         for w in GA.coordList:
    #             for t in GA.coordList[w][1]:
    #                 if GA.coordList[w][1]:
    #                     print("skssksksk")
    #                     if x in range(0,t):
    #                         print(w)
    #                         probset=[w,valueLab,valueprob]
    #                         print(probset)

    obsLabel = askstring('value', 'Please enter either T or F')

    # obsCoord = {}
    # obs = {}
    # for h in GA.coordList:
    #     obsCoord[h] = set()
    #
    #     if x>0:
    #         for f in GA.coordList:
    #             for d in GA.coordList[f][1]:
    #                 if GA.coordList[f][1]:
    #                     print("werterwt")
    #                     if x ==d:
    #                         print(f)


    #need it to not overwrite one another
    if obsLabel == 'T':
        obs = [obsLabel]
        print(obs)
    elif obsLabel == 'F':
        obs = [obsLabel]
        print(obs)
    elif obsLabel is None:
        print("asassa")
    else:
        #dont print the label
        obsError = tkinter.messagebox.showinfo('error','Please only enter either T or F')

    return obs
    print(obs)

        # trueVar=IntVar()
    # valueObs = tkinter.
    # obsTrue = Checkbutton(canvas,text="True",variable=trueVar)


    # #want a dictionary store nodeID and T/F
    #
    # Label(root, text="Select Node:").pack(side=LEFT)
    #
    # e1 = Entry(root)
    #
    # e1.pack(side=LEFT)
    #
    # chosenNode = e1.get()
    #
    # #check after input then print
    # #alt create a button that confirms the input then prints
    # #store in a list - as order is necessary must be t/f then value
    #
    # print("aaaaaa")
    # print(chosenNode) #not printing????
    # print("bbbb")
    #
    #
    # global truevar
    #
    # truevar = IntVar()
    #
    # true = Checkbutton(root, text="True", variable=truevar)
    # true.pack(side=LEFT)
    #
    # falsevar=IntVar()
    # false = Checkbutton(root, text="False", variable=falsevar)
    # false.pack(side=LEFT)
    # falsevar.get()
    # # print(falsevar.get())
    #
    #
    # print("eeeee")
    # truevar.get()
    #
    # print(truevar.get())
    #
    #
    #
    # print("ccccc")

def SetObs(event):
    root.config(cursor="cross")
    canvas.bind("<Button-1>", setTF)

def run(event):
    print("asdawdwa")


button1.bind("<Button-1>",CreateNode)
button2.bind("<Button-1>",CreateArc)
button3.bind("<Button-1>",probTable)
button4.bind("<Button-1>",ParentProb)
# button5.bind("<Button-1>",ParentProb)
button6.bind("<Button-1>", SetObs)
button7.bind("<Button-1>",run)


root.mainloop()
